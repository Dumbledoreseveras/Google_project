# -*- coding: utf-8 -*-
"""Google_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l4SHZ4115z1E7n7SqOotL3JU5jwXhiK5
"""

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.io as pio
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import webbrowser
import os
import warnings
warnings.filterwarnings('ignore')

"""# Vader_lexicon= sentiment analysis"""

nltk.download('vader_lexicon')

apps_df = pd.read_csv('/content/Play Store Data.csv')
reviews_df = pd.read_csv('/content/User Reviews.csv')

apps_df.head()

reviews_df.head()

"""# Data Cleaning"""

apps_df = apps_df.dropna(subset=['Rating'])
for column in apps_df.columns :
    apps_df[column].fillna(apps_df[column].mode()[0],inplace=True)
apps_df.drop_duplicates(inplace=True)
apps_df=apps_df=apps_df[apps_df['Rating']<=5]
reviews_df.dropna(subset=['Translated_Review'],inplace=True)

apps_df.dtypes

"""#Data Transmission"""

apps_df['Installs'] = apps_df['Installs'].astype(str).str.replace(',','').str.replace('+','').astype(int)
apps_df['Price'] = apps_df['Price'].astype(str).str.replace('$','').astype(float)

apps_df.dtypes

"""#Merge csv file"""

merge_df = pd.merge(apps_df, reviews_df, on='App', how='inner')
merge_df.head()

"""# Size converstion"""

def convert_size(size):
  if 'M' in size:
    return float (size.replace('M',''))
  elif 'K' in size:
    return float (size.replace('K',''))/1024
  else:
    return np.nan
apps_df['Size'] = apps_df['Size'].apply(convert_size)

apps_df.head()

"""# Log Transformation"""

apps_df['Log_Installs'] = np.log(apps_df['Installs'])

apps_df['Reviews'] = apps_df['Reviews'].astype(int)   #change type of Reviews
apps_df['Log_Reviews'] = np.log(apps_df['Reviews'])

apps_df.head()

"""# Categorised Ratings"""

def rating_group(rating):
  if rating >= 4:
    return 'Top rated app'
  elif rating >= 3:
    return 'Above average'
  elif rating >= 2:
    return 'Average'
  else:
    return 'Below average'
apps_df['Rating_group'] = apps_df['Rating'].apply(rating_group)

apps_df.head()

apps_df['Revenue'] = apps_df['Price']*apps_df['Installs']

apps_df.head()

"""# Sentiment analysis"""

sia = SentimentIntensityAnalyzer()

reviews_df['Sentiment_Score'] = reviews_df['Translated_Review'].apply(lambda x: sia.polarity_scores(str(x))['compound'])
reviews_df.head()

"""# Checking any particular date time"""

apps_df['Last Updated'] = pd.to_datetime(apps_df['Last Updated'], errors = 'coerce')

#for know the year
apps_df['Year'] = apps_df['Last Updated'].dt.year

apps_df.head()

"""#Plotly"""

# Code for Directory
html_files_path = "./"
if not os.path.exists(html_files_path):
  os.makedirs(html_files_path)

# Empty string
  plot_containers = ""

# Define function
def save_plot_as_html(fig, filename, insight):
  global plot_containers
  filepath = os.path.join(html_files_path, filename)
  html_content = pio.to_html(fig, full_html = False, include_plotlyjs = "inline")

  # It appends html code to the plote container
  plot_containers += f"""
  <div class = "plot-container" id ="{filename}"
  onclick = "openPlot('{filename}')">
  <div class = "plot"> {html_content}</div>
  <div class = "insight">{insight}</div>
  </div>
  """
  fig.write_html(filepath, full_html = False, include_plotlyjs = "inline")

#plot cintainers should be like
plot_width = 400
plot_height = 300
plot_bg_color = 'black'
text_color = 'white'
title_font = {'size': 16}
axis_font = {'size': 12}

# Analyze category top 10 apps
#figure 1
category_counts = apps_df['Category'].value_counts().nlargest(10)
fig1 =px.bar(
    x = category_counts.index,
    y = category_counts.values,
    labels = {'x': 'Category', 'y': 'Count'},
    title = 'Top Categories on Play Store',
    color = category_counts.index,
    color_discrete_sequence = px.colors.sequential.Plasma,
    width = 400,
    height = 300
)
fig1.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig1.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig1, "Category Graph 1.html", "The top categories on the Play Store are dominated by tools, entertainment, and productivity apps.")

# Figure 2
type_counts = apps_df['Type'].value_counts()
fig2 = px.pie(
    values =type_counts.values,
    names = type_counts.index,
    title = 'App type Distribution',
    color_discrete_sequence = px.colors.sequential.RdBu,
    width = 400,
    height = 300
)
fig2.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig2.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig2, "Type Graph 2.html", "The majority of apps on the Play Store are free, indicating a stratergy to attract users first.")

#Histogram
#Rating Distribution
#figure 3

fig3 = px.histogram(
    apps_df,
    x = 'Rating',
    nbins = 20,
    title = 'Rating Distribution',
    color_discrete_sequence = ['#636EFA'],
    width = 400,
    height = 300
)
fig3.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig3.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig3, "Rating Graph 3.html", "Ratings are skewed towards higher values, suggesting that most apps are rated favorably by users.")

# Sentiment analysis
# Figure 4

sentiment_counts = reviews_df['Sentiment_Score'].value_counts()
fig4 =px.bar(
    x = sentiment_counts.index,
    y = sentiment_counts.values,
    labels = {'x': 'Sentiment Score', 'y': 'Count'},
    title = 'Sentiment Distribution',
    color = sentiment_counts.index,
    color_discrete_sequence = px.colors.sequential.RdPu,
    width = 400,
    height = 300
)
fig4.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig4.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig4, "Sentiment Graph 4.html", "Sentiment in reviews show a mix of positive and negative feedback.")

# Installs apps by category
# Figure 5

installs_by_category = apps_df.groupby('Category')['Installs'].sum().nlargest(10)
fig5 =px.bar(
    x = installs_by_category.index,
    y = installs_by_category.values,
    orientation = 'h',
    labels = {'x': 'Installs', 'y': 'Category'},
    title = 'Installs by Category',
    color =installs_by_category.index,
    color_discrete_sequence = px.colors.sequential.Blues,
    width = 400,
    height = 300
)
fig5.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig5.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig5, "Installs Graph 5.html", "The category with the most installs are social and communication apps, reflecting their broad appeal and daily usage.")

# Analyze Upadate app over the Year
#figure 6
updates_per_year = apps_df['Last Updated'].dt.year.value_counts().sort_index()
fig6 =px.line(
    x = updates_per_year.index,
    y = updates_per_year.values,
    labels = {'x': 'Year', 'y': 'Number of Upadates'},
    title = 'Number of Updates over the Year',
    color_discrete_sequence = ['#AB63EF'],
    width = plot_width,
    height = plot_height
)
fig6.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig6.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig6, "Update Graph 6.html", "Upadtes have been increasing over the year, showing our devloper are actively maintaining and improving apps.")

# Revenue by category
# Figure 7
revenue_by_category = apps_df.groupby('Category')['Revenue'].sum().nlargest(10)
fig7 =px.bar(
    x = revenue_by_category.index,
    y = revenue_by_category.values,
    labels = {'x': 'Category', 'y': 'Revenue'},
    title = 'Revenue by Category',
    color =revenue_by_category.index,
    color_discrete_sequence = px.colors.sequential.Greens,
    width = 400,
    height = 300
)
fig7.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig7.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig7, "Revenue Graph 7.html", "Category such as Business and Productivity lead in revenue generation, indicating their monetizition potential.")

# Genres
# Figure 8

genre_counts = apps_df['Genres'].str.split(";", expand = True).stack().value_counts().nlargest(10)
fig8 =px.bar(
    x = genre_counts.index,
    y = genre_counts.values,
    labels = {'x': 'Genre', 'y': 'Count'},
    title = 'Top Genres',
    color =genre_counts.index,
    color_discrete_sequence = px.colors.sequential.OrRd,
    width = 400,
    height = 300
)
fig8.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig8.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig8, "Genre Graph 8.html", "Action and Casual genres are the most common, reflecting users' preference for engaging and easy- to-play games.")

# Analyze to relationship between last update and app ratings
# Figure 9

fig9 = px.scatter(
    apps_df,
    x = 'Last Updated',
    y = 'Rating',
    color = 'Type',
    title = 'Relationship between Last Update and Ratings',
    color_discrete_sequence = px.colors.qualitative.Vivid,
    width = 400,
    height = 300
)
fig9.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig9.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig9, "Last updated vs Ratings Graph 9.html", "The scatter plot shows a weak correlation between the last update and ratings, Suggesting that more frequent updates in play store.")

# Distribution of rating for each group
# Figure 10

fig10 = px.box(
    apps_df,
    x = 'Type',
    y = 'Rating',
    color = 'Type',
    title = 'Rating for Paid vs Free Apps',
    color_discrete_sequence = px.colors.qualitative.Pastel,
    width = 400,
    height = 300
)
fig10.update_layout(
    plot_bgcolor = 'black',
    paper_bgcolor = 'black',
    font_color = 'white',
    title_font = {'size':16},
    xaxis = dict(title_font = {'size':12}),
    yaxis = dict(title_font = {'size':12}),
    margin = dict(l = 10, r = 10, t = 30, b = 10)
)

fig10.update_traces(marker = dict(line = dict(color = text_color, width = 1)))
save_plot_as_html(fig10, "Paid Free Graph 10.html", "Paid apps have higher ratings compared to freee apps, Suggesting that users expect higher quality from apps they pay for.")

# All plot in one html

plot_containers_split = plot_containers.split('</div>')

if len(plot_containers_split) > 1:
  final_plot = plot_containers.split()[-2]+'</div>'
else:
  final_plot = plot_containers

dashboard_html = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Play Store Review Analytics</title>
    <style>
      body {{
        font-family: Arial, sans-serif;
        background-color: #333;
        color: #fff;
        margin: 0;
        padding: 0;
      }}
      .header{{
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        background-color: #444;
      }}
      .header img{{
        margin-right: 10px;
        height: 50px;
      }}
      .container{{
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        padding:20x
      }}
      .plot-container{{
        border: 2px solid #555;
        border-radius: 10px;
        width: {plot_width}px;
        height: {plot_height}px;
        overflow: hidden;
        position: relative;
        cursor: pointer;
        }}
        .insight{{
          display: none;
          position: absolute;
          right: 10px;
          top: 10px;
          background-color: rgba(0,0,0,0.7);
          padding: 5px
          border-radius: 5px
          color: #fff;
        }}
        .plot-container: hover .insights{{
          display: block;
        }}
        </style>
        <script>
            function openPlot(filename) {{
              window.open(filename, '_blank');
            }}
        </script>
</head>
<body>
    <div class = "header">
      <img src ="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Logo_2013_Google.png/800px-Logo_2013_Google.png" alt = "Google Logo">
      <h1>Google Play Store Review Analytics</h1>
      <img src = "https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Google_Play_Store_badge_EN.svg/1024px-Google_Play_Store_badge_EN.svg.png" alt = "Google Logo">
    </div>
    <div class = "container">
      {plots}
    </div>
</body>
</html>
"""

final_html = dashboard_html.format(plots=plot_containers, plot_width=plot_width, plot_height=plot_height)

dashboard_path=os.path.join(html_files_path, "Dashboard.html")
with open(dashboard_path, "w", encoding = "utf-8") as f:
  f.write(final_html)

webbrowser.open('file://'+os.path.realpath(dashboard_path))